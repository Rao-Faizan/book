"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[5190],{1673:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"module1/chapter1","title":"Understanding ROS 2 Architecture and Core Concepts","description":"This chapter introduces the fundamental concepts of ROS 2, focusing on its distributed architecture, core communication mechanisms, and the role of DDS middleware. By the end of this chapter, you will be able to diagram a simple ROS 2 system, identify its components, and explain how they communicate.","source":"@site/docs/module1/chapter1.mdx","sourceDirName":"module1","slug":"/module1/chapter1","permalink":"/book/docs/module1/chapter1","draft":false,"unlisted":false,"editUrl":"https://github.com/Rao-Faizan/book/tree/master/docs/module1/chapter1.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"chapter1","title":"Understanding ROS 2 Architecture and Core Concepts","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Module 1: The Robotic Nervous System (ROS 2)","permalink":"/book/docs/category/module-1-the-robotic-nervous-system-ros-2"},"next":{"title":"Building ROS 2 Nodes with Python (rclpy)","permalink":"/book/docs/module1/chapter2"}}');var r=n(4848),t=n(8453);const o={id:"chapter1",title:"Understanding ROS 2 Architecture and Core Concepts",sidebar_position:1},a="Understanding ROS 2 Architecture and Core Concepts",c={},l=[{value:"ROS 2 Distributed Architecture",id:"ros-2-distributed-architecture",level:2},{value:"DDS (Data Distribution Service) Middleware",id:"dds-data-distribution-service-middleware",level:3},{value:"Core ROS 2 Concepts",id:"core-ros-2-concepts",level:2},{value:"Nodes",id:"nodes",level:3},{value:"Topics (Publish-Subscribe)",id:"topics-publish-subscribe",level:3},{value:"Services (Request-Response)",id:"services-request-response",level:3},{value:"Actions (Long-Running with Feedback)",id:"actions-long-running-with-feedback",level:3},{value:"Computational Graph",id:"computational-graph",level:3},{value:"ROS 2 Humble Hawksbill LTS",id:"ros-2-humble-hawksbill-lts",level:3},{value:"ROS 2 Humble Installation Instructions",id:"ros-2-humble-installation-instructions",level:2},{value:"ROS 2 CLI Tools",id:"ros-2-cli-tools",level:2},{value:"QoS (Quality of Service) Policies",id:"qos-quality-of-service-policies",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"understanding-ros-2-architecture-and-core-concepts",children:"Understanding ROS 2 Architecture and Core Concepts"})}),"\n",(0,r.jsx)(i.p,{children:"This chapter introduces the fundamental concepts of ROS 2, focusing on its distributed architecture, core communication mechanisms, and the role of DDS middleware. By the end of this chapter, you will be able to diagram a simple ROS 2 system, identify its components, and explain how they communicate."}),"\n",(0,r.jsx)(i.h2,{id:"ros-2-distributed-architecture",children:"ROS 2 Distributed Architecture"}),"\n",(0,r.jsx)(i.p,{children:"Unlike ROS 1, ROS 2 features a distributed architecture with no central master. This design enhances scalability, reliability, and security, making it suitable for a wider range of robotic applications, from single-robot systems to large-scale deployments."}),"\n",(0,r.jsx)(i.h3,{id:"dds-data-distribution-service-middleware",children:"DDS (Data Distribution Service) Middleware"}),"\n",(0,r.jsx)(i.p,{children:"ROS 2 leverages the Data Distribution Service (DDS) as its primary communication middleware. DDS is an open international standard for real-time systems that enables efficient, reliable, and secure data exchange between distributed applications. It handles discovery, serialization, and transport, allowing ROS 2 nodes to communicate seamlessly without a central server."}),"\n",(0,r.jsx)(i.h2,{id:"core-ros-2-concepts",children:"Core ROS 2 Concepts"}),"\n",(0,r.jsx)(i.p,{children:"ROS 2 organizes its functionalities around several core concepts that facilitate modular and robust robot software development."}),"\n",(0,r.jsx)(i.h3,{id:"nodes",children:"Nodes"}),"\n",(0,r.jsxs)(i.p,{children:["A ",(0,r.jsx)(i.strong,{children:"node"})," is an executable process that performs a specific task within the ROS 2 computational graph. Nodes are modular and can be written in various programming languages (e.g., Python, C++). Examples include a camera driver node, a motor controller node, or a navigation algorithm node."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-mermaid",children:"graph TD\r\n    A[Camera Node] --\x3e B(Image Processing Node)\r\n    B --\x3e C{Decision-Making Node}\r\n    C --\x3e D[Motor Control Node]\n"})}),"\n",(0,r.jsx)(i.h3,{id:"topics-publish-subscribe",children:"Topics (Publish-Subscribe)"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Topics"})," are named buses over which nodes exchange messages using a publish-subscribe communication model. A node ",(0,r.jsx)(i.strong,{children:"publishes"})," messages to a topic, and other nodes ",(0,r.jsx)(i.strong,{children:"subscribe"})," to that topic to receive the messages. This asynchronous, one-to-many communication pattern is ideal for streaming data, such as sensor readings or robot state updates."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-mermaid",children:"graph LR\r\n    Publisher[Publisher Node] -- publishes --\x3e Topic(Sensor Data Topic)\r\n    Topic -- subscribes --\x3e Subscriber1[Subscriber Node 1]\r\n    Topic -- subscribes --\x3e Subscriber2[Subscriber Node 2]\n"})}),"\n",(0,r.jsx)(i.h3,{id:"services-request-response",children:"Services (Request-Response)"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Services"})," provide a synchronous request-response communication mechanism between nodes. A ",(0,r.jsx)(i.strong,{children:"service client"})," sends a request to a ",(0,r.jsx)(i.strong,{children:"service server"}),", which processes the request and returns a response. This is useful for operations that require an immediate result, like querying a robot's current pose or triggering a specific action."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-mermaid",children:"graph LR\r\n    Client[Client Node] -- request --\x3e Service(Calculate Sum Service)\r\n    Service -- response --\x3e Client\r\n    Service --\x3e Server[Server Node]\n"})}),"\n",(0,r.jsx)(i.h3,{id:"actions-long-running-with-feedback",children:"Actions (Long-Running with Feedback)"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Actions"})," are designed for long-running tasks that may require periodic feedback and the ability to be preempted. An ",(0,r.jsx)(i.strong,{children:"action client"})," sends a goal to an ",(0,r.jsx)(i.strong,{children:"action server"}),", which executes the task and provides continuous feedback on its progress. The client can also cancel the goal if needed. This is commonly used for tasks like navigating to a specific location or manipulating an object."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-mermaid",children:"graph LR\r\n    Client[Action Client] -- goal --\x3e Action(Move Robot Action)\r\n    Action -- feedback --\x3e Client\r\n    Action -- result --\x3e Client\r\n    Action --\x3e Server[Action Server]\n"})}),"\n",(0,r.jsx)(i.h3,{id:"computational-graph",children:"Computational Graph"}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.strong,{children:"computational graph"})," is a network of all the ROS 2 nodes, topics, services, and actions running in a system. It represents the data flow and communication pathways, providing a high-level overview of how different components interact to achieve a robot's overall functionality."]}),"\n",(0,r.jsx)(i.h3,{id:"ros-2-humble-hawksbill-lts",children:"ROS 2 Humble Hawksbill LTS"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"ROS 2 Humble Hawksbill"})," is a Long Term Support (LTS) release of ROS 2, providing extended maintenance and support until 2027. It is a stable and widely adopted distribution, compatible with Ubuntu 22.04 LTS, making it an excellent choice for developing robust and production-ready robotic applications."]}),"\n",(0,r.jsx)(i.h2,{id:"ros-2-humble-installation-instructions",children:"ROS 2 Humble Installation Instructions"}),"\n",(0,r.jsxs)(i.p,{children:["To install ROS 2 Humble Hawksbill, ",(0,r.jsx)(i.strong,{children:"we recommend following the official documentation for Ubuntu 22.04 LTS"}),", as this is the standard distribution for this course:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Ubuntu (recommended)"}),": ",(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html",children:"ROS 2 Humble Hawksbill Installation on Ubuntu"})]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Windows"}),": ",(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/humble/Installation/Windows-Install-Binary.html",children:"ROS 2 Humble Hawksbill Installation on Windows"})]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"macOS"}),": ",(0,r.jsx)(i.a,{href:"https://docs.ros.org/en/humble/Installation/macOS-Install-Binary.html",children:"ROS 2 Humble Hawksbill Installation on macOS"})]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"ros-2-cli-tools",children:"ROS 2 CLI Tools"}),"\n",(0,r.jsx)(i.p,{children:"ROS 2 provides a powerful set of command-line interface (CLI) tools for interacting with and debugging ROS 2 systems. Some commonly used tools include:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ros2 run"}),": Run an executable from a package."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ros2 topic"}),": Inspect topics (e.g., ",(0,r.jsx)(i.code,{children:"ros2 topic list"}),", ",(0,r.jsx)(i.code,{children:"ros2 topic echo <topic_name>"}),")."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ros2 node"}),": Inspect nodes (e.g., ",(0,r.jsx)(i.code,{children:"ros2 node list"}),", ",(0,r.jsx)(i.code,{children:"ros2 node info <node_name>"}),")."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ros2 service"}),": Inspect services (e.g., ",(0,r.jsx)(i.code,{children:"ros2 service list"}),", ",(0,r.jsx)(i.code,{children:"ros2 service call <service_name> <type> <args>"}),")."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ros2 param"}),": Inspect parameters (e.g., ",(0,r.jsx)(i.code,{children:"ros2 param list"}),", ",(0,r.jsx)(i.code,{children:"ros2 param get <node_name> <param_name>"}),")."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ros2 launch"}),": Run a launch file."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"qos-quality-of-service-policies",children:"QoS (Quality of Service) Policies"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"QoS (Quality of Service) policies"})," in ROS 2 allow developers to configure the reliability, durability, and latency characteristics of topic communication. These policies ensure that data is delivered according to the application's specific requirements, especially in real-time and safety-critical systems. Key QoS policies include:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Reliability"}),": Guarantees message delivery (or not)."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Durability"}),": Specifies if messages persist for late-joining subscribers."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"History"}),": Configures how many messages are stored."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Liveliness"}),": Detects if publishers are active."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Deadline"}),": Sets a maximum expected time between messages."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Understanding and configuring QoS policies is crucial for building robust and predictable ROS 2 applications."})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var s=n(6540);const r={},t=s.createContext(r);function o(e){const i=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:i},e.children)}}}]);