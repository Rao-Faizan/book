---
title: Building ROS 2 Nodes with Python (rclpy)
description: Learn how to create ROS 2 nodes using rclpy, including publishers, subscribers, services, and parameters.
sidebar_position: 2
---

## rclpy Library Structure and Imports

`rclpy` is the Python client library for ROS 2. To start creating ROS 2 nodes with Python, you need to understand the basic structure and import the necessary modules.

The core modules you'll use are:

- `rclpy`: The main entry point for using `rclpy`.
- `rclpy.node`: For creating and working with nodes.
- `rclpy.publisher`: For creating publishers.
- `rclpy.subscription`: For creating subscribers.
- `rclpy.service`: For creating services.
- `rclpy.client`: For creating clients.
- `rclpy.timer`: For creating timers.
- `rclpy.parameter`: For working with parameters.

Here's how you import these modules:

```python
import rclpy
from rclpy.node import Node
from rclpy.publisher import Publisher
from rclpy.subscription import Subscription
from rclpy.service import Service
from rclpy.client import Client
from rclpy.timer import Timer
from rclpy.parameter import Parameter
```

## Node Initialization and Creation

In `rclpy`, a node represents a computational unit in the ROS 2 network. To create a node, you first need to initialize `rclpy`, then create a class that inherits from `rclpy.node.Node`.

Here's a basic example:

```python
import rclpy
from rclpy.node import Node

class MyNode(Node):
    def __init__(self):
        super().__init__('my_node')

def main(args=None):
    rclpy.init(args=args)
    node = MyNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

In this example:

- We import `rclpy` and `rclpy.node`.
- We create a class `MyNode` that inherits from `Node`.
- In the constructor, we call the superclass constructor with the node name `'my_node'`.
- In the `main` function, we initialize `rclpy`, create an instance of `MyNode`, spin the node (which keeps it alive and processing callbacks), destroy the node, and shutdown `rclpy`.

## Creating Publishers

In ROS 2, publishers are responsible for sending messages to topics. To create a publisher, you need to use the `create_publisher` method of the `Node` class.

Here's an example of creating a publisher:

```python
from std_msgs.msg import String

class MyNode(Node):
    def __init__(self):
        super().__init__('my_node')
        self.publisher_ = self.create_publisher(String, 'my_topic', 10)
```

In this example:

- We import the `String` message type from the `std_msgs.msg` module.
- In the constructor of `MyNode`, we create a publisher using `self.create_publisher`.
- The first argument is the message type (`String`).
- The second argument is the topic name (`'my_topic'`).
- The third argument is the queue size (10).

### Creating Subscribers

Subscribers are used to receive messages published on topics. To create a subscriber, you use the `create_subscription` method.

```python
from std_msgs.msg import String

class MySubscriberNode(Node):
    def __init__(self):
        super().__init__('my_subscriber_node')
        self.subscription = self.create_subscription(
            String,
            'my_topic',
            self.listener_callback,
            10)
        self.get_logger().info('Subscriber created, waiting for messages...')

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    node = MySubscriberNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

In this example:

- We create a `MySubscriberNode` that inherits from `Node`.
- Inside the constructor, `self.create_subscription` is used to subscribe to the `'my_topic'` topic.
- The `listener_callback` method is defined to process incoming messages. This method will be called whenever a new message arrives on the topic.
- The `get_logger().info` is used to print messages, which is the standard way to log in ROS 2.

### Timer Creation for Periodic Publishing

Timers allow nodes to execute a callback function at a specified rate. This is commonly used for periodic publishing of data.

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        self.timer = self.create_timer(0.5, self.timer_callback)  # Timer calls callback every 0.5 seconds
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello from publisher: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    rclpy.spin(minimal_publisher)
    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

In this example:
- We create a `create_timer` with a period of 0.5 seconds, which calls `timer_callback`.
- The `timer_callback` function creates and publishes a `String` message.

### Service Server Implementation

Services provide a synchronous request-response mechanism. A service server waits for requests, processes them, and sends back a response.

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts # Assuming this service type exists

class MinimalService(Node):
    def __init__(self):
        super().__init__('minimal_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)
        self.get_logger().info('Service server started.')

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}, sending response: {response.sum}')
        return response

def main(args=None):
    rclpy.init(args=args)
    minimal_service = MinimalService()
    rclpy.spin(minimal_service)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

In this example:
- We import `AddTwoInts` service type (you might need to create an `example_interfaces` package or use an existing service type).
- `create_service` registers the `add_two_ints_callback` function to handle requests on the `add_two_ints` service.
- The callback function receives a `request` and populates the `response` with the sum.

### Service Client Implementation

A service client sends a request to a service server and waits for its response.

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts
import sys

class MinimalClientAsync(Node):
    def __init__(self):
        super().__init__('minimal_client_async')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()

def main(args=None):
    rclpy.init(args=args)
    minimal_client = MinimalClientAsync()
    response = minimal_client.send_request(int(sys.argv[1]), int(sys.argv[2]))
    minimal_client.get_logger().info(f'Result of add_two_ints: {response.sum}')
    minimal_client.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

In this example:
- `create_client` creates a client for the `add_two_ints` service.
- `send_request` populates the request and calls the service asynchronously using `call_async`.
- `rclpy.spin_until_future_complete` blocks until the response is received.

### Callback Functions and Callback Groups

**Callback functions** are essential for event-driven programming in ROS 2. They are executed when a specific event occurs, such as a new message on a topic, a service request, or a timer expiring.

**Callback groups** allow you to manage the execution of multiple callbacks. By default, all callbacks in a node belong to a single default callback group, which executes them sequentially. For concurrent execution, you can create multiple callback groups and assign callbacks to them. This is advanced usage and typically not needed for basic nodes, but it's important for ensuring real-time performance in complex systems.

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MyConcurrentNode(Node):
    def __init__(self):
        super().__init__('my_concurrent_node')
        # Default callback group (sequential execution)
        self.subscription_ = self.create_subscription(
            String,
            'topic',
            self.default_callback,
            10)
        self.timer_ = self.create_timer(1.0, self.timer_callback)

    def default_callback(self, msg):
        self.get_logger().info(f'Default callback received: "{msg.data}"')

    def timer_callback(self):
        self.get_logger().info('Timer callback triggered.')

# For concurrent execution, you would create different callback groups.
# Example (conceptual, requires more setup for executor):
# from rclpy.callback_groups import ReentrantCallbackGroup
# self.reentrant_group = ReentrantCallbackGroup()
# self.subscription_reentrant = self.create_subscription(
#     String,
#     'reentrant_topic',
#     self.reentrant_callback,
#     10,
#     callback_group=self.reentrant_group)

def main(args=None):
    rclpy.init(args=args)
    node = MyConcurrentNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Standard Message Types

ROS 2 uses a variety of standard message types to facilitate communication between nodes. These messages are defined in packages like `std_msgs`, `geometry_msgs`, `sensor_msgs`, and `rcl_interfaces`. Understanding these common message types is crucial for building interoperable ROS 2 applications.

*   **`std_msgs`**: Contains basic data types like `String`, `Int32`, `Bool`, `Float64`, etc.
*   **`geometry_msgs`**: Used for geometric primitives such as `Point`, `Pose`, `Quaternion`, `Twist` (linear and angular velocity), and `Transform`.
*   **`sensor_msgs`**: Contains messages for common sensor data, including `Image`, `LaserScan`, `Imu` (Inertial Measurement Unit), and `PointCloud2`.
*   **`rcl_interfaces`**: Provides common interfaces for ROS 2, such as `ParameterDescriptor` and `SetParametersResult` for parameter management, and `Log` for logging messages.

To use these message types, you typically import them as shown in the examples:

```python
from std_msgs.msg import String
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Image
```

### Parameter Declaration and Access

Parameters allow you to configure nodes at runtime without recompiling the code. This is useful for adjusting behaviors, such as a PID controller's gains or a camera's exposure setting. `rclpy` provides methods to declare, get, and set parameters.

```python
import rclpy
from rclpy.node import Node
from rclpy.parameter import Parameter

class ParameterNode(Node):
    def __init__(self):
        super().__init__('parameter_node')
        self.declare_parameter('my_parameter', 'hello')
        self.declare_parameter('an_integer_parameter', 1)

        param = self.get_parameter('my_parameter')
        self.get_logger().info(f'Initial parameter value: {param.value}')

        # You can also get a parameter directly as a type
        int_param = self.get_parameter('an_integer_parameter').value
        self.get_logger().info(f'Integer parameter value: {int_param}')

        # Setting a parameter
        self.set_parameters([Parameter('my_parameter', Parameter.Type.STRING, 'world')])
        new_param = self.get_parameter('my_parameter')
        self.get_logger().info(f'New parameter value: {new_param.value}')

def main(args=None):
    rclpy.init(args=args)
    node = ParameterNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

In this example:
- `declare_parameter()` is used to define a parameter with a default value.
- `get_parameter()` retrieves the current value of a parameter.
- `set_parameters()` allows you to change parameter values at runtime.

### QoS Profiles in Practice

Quality of Service (QoS) policies in ROS 2 allow you to define how messages are exchanged between publishers and subscribers. These policies are critical for managing reliability, latency, and resource usage in real-time robotic applications. `rclpy` provides the `QoSProfile` class and several common presets.

```python
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy
from std_msgs.msg import String

class QoSNode(Node):
    def __init__(self):
        super().__init__('qos_node')

        # Define a custom QoS profile
        qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE,
            durability=DurabilityPolicy.RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL,
            history=HistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_LAST,
            depth=10
        )

        # Publisher with custom QoS profile
        self.publisher_ = self.create_publisher(String, 'qos_topic', qos_profile)
        self.timer_ = self.create_timer(1.0, self.timer_callback)

        # Subscriber with custom QoS profile (should match publisher for connection)
        self.subscription_ = self.create_subscription(
            String,
            'qos_topic',
            self.listener_callback,
            qos_profile)

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello with QoS'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')

    def listener_callback(self, msg):
        self.get_logger().info(f'Received: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    node = QoSNode()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

Key QoS Policies:
*   **Reliability**: `RMW_QOS_POLICY_RELIABILITY_RELIABLE` (guarantees delivery) vs. `RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT` (no guarantee, faster).
*   **Durability**: `RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL` (messages persist for new subscribers) vs. `RMW_QOS_POLICY_DURABILITY_VOLATILE` (only current subscribers receive).
*   **History**: `RMW_QOS_POLICY_HISTORY_KEEP_LAST` (keep last N messages) vs. `RMW_QOS_POLICY_HISTORY_KEEP_ALL` (keep all messages).
*   **Depth**: Number of messages to keep if `HistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_LAST` is used.

Common Presets:
*   `QoSProfile.DEFAULT_QOS`
*   `QoSProfile.SERVICES_DEFAULT`
*   `QoSProfile.PARAMETERS`
*   `QoSProfile.SENSOR_DATA`

### Debugging Techniques

Debugging ROS 2 nodes is crucial for identifying and resolving issues in your robotic applications. `rclpy` and the ROS 2 CLI tools provide several mechanisms to help with this.

#### Using ROS 2 CLI Tools

*   **`ros2 node list`**: Lists all active nodes in the ROS 2 graph. Use this to ensure your node is running.
*   **`ros2 topic list`**: Shows all active topics. Use `ros2 topic echo <topic_name>` to inspect messages being published on a topic.
*   **`ros2 service list`**: Lists active services. Use `ros2 service call <service_name> <service_type> <arguments>` to test service servers.
*   **`ros2 param list`**: Lists parameters for a specific node. Use `ros2 param get <node_name> <parameter_name>` and `ros2 param set <node_name> <parameter_name> <value>` to inspect and modify parameters at runtime.
*   **`ros2 launch`**: For complex systems, `ros2 launch <package_name> <launch_file>` is essential. Debugging launch files often involves checking the output for errors and ensuring all nodes start correctly.

#### Recommended VS Code Debugging Features

For Python nodes, VS Code with the appropriate Python and ROS extensions provides powerful debugging capabilities:

*   **Breakpoints**: Set breakpoints in your Python code to pause execution and inspect variables.
*   **Variable Inspection**: Examine the values of variables at breakpoints.
*   **Step-through Debugging**: Step into, over, or out of functions to follow the execution flow.
*   **Call Stack**: View the sequence of function calls that led to the current point of execution.

**Note for alternative IDE users**: If you are using `vim`, `emacs`, `PyCharm`, or other IDEs, you are responsible for adapting these debugging instructions to your chosen environment. The principles remain the same: leverage breakpoints, inspect variables, and step through code execution.
