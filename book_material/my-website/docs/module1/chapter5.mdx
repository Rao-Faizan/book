---
id: chapter5
title: Launch Files and Package Management
sidebar_position: 5
---

## Launch Files and Package Management

As your ROS 2 systems grow in complexity, manually starting individual nodes becomes impractical. This chapter teaches you how to use **launch files** to manage multi-node systems and organize your code into **ROS 2 packages** following professional development practices.

### Learning Objectives
By the end of this chapter, you will be able to:
- Understand the purpose and benefits of launch files for complex robot systems.
- Write Python launch files using ROS 2 launch syntax.
- Configure nodes with parameters and remappings in launch files.
- Use launch arguments for flexible, reusable launch configurations.
- Structure ROS 2 packages following standard conventions.
- Configure package metadata and dependencies in `package.xml`.
- Set up Python package entry points in `setup.py`.
- Build and manage packages using the `colcon` build system.
- Handle workspace overlays and environment sourcing.
- Manage dependencies with `rosdep`.
- Apply best practices for documentation, testing, and versioning.

---

## 5.1 Introduction to Launch Files

### Why Launch Files?

Imagine a humanoid robot system with:
- 5 sensor nodes (camera, lidar, IMU, force sensors)
- 10 control nodes (one per limb joint controller)
- 3 planning nodes (navigation, manipulation, balance)
- 2 visualization nodes (RViz2, diagnostics)

Starting 20+ nodes manually in separate terminals is error-prone and time-consuming. **Launch files** solve this by:

- **Automating startup**: Launch all nodes with a single command
- **Managing configuration**: Set parameters, remappings, and environment variables
- **Enabling flexibility**: Use arguments to switch between simulation and hardware
- **Improving reproducibility**: Standardize system configuration across team members

### Launch System Architecture

ROS 2's launch system is built on Python (unlike ROS 1's XML-based launch files), providing:
- Full programming capabilities (conditionals, loops, functions)
- Type safety and IDE support
- Modular composition (include other launch files)
- Event-based execution (react to node lifecycle changes)

---

## 5.2 Python Launch File Syntax

### Basic Structure

A launch file is a Python script with a `generate_launch_description()` function:

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_robot_control',
            executable='velocity_controller',
            name='velocity_controller_node'
        )
    ])
```

**Key components**:
- `LaunchDescription`: Container for launch actions
- `Node`: Action to start a ROS 2 node
- `package`: Package containing the executable
- `executable`: Name of the node executable (from `setup.py` entry points)
- `name`: Runtime name for the node (overrides default)

### Starting Multiple Nodes

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        # Sensor node
        Node(
            package='sensor_drivers',
            executable='camera_node',
            name='head_camera',
            output='screen'  # Print output to console
        ),
        
        # Control node
        Node(
            package='robot_control',
            executable='arm_controller',
            name='left_arm_controller',
            output='screen'
        ),
        
        # Planning node
        Node(
            package='motion_planning',
            executable='trajectory_planner',
            name='planner',
            output='screen'
        )
    ])
```

**`output` parameter**:
- `'screen'`: Display node output in terminal
- `'log'`: Write output to log files only
- Default: `'log'`

### Running a Launch File

```bash
ros2 launch my_robot_bringup robot.launch.py
```

Or from a package:
```bash
ros2 launch <package_name> <launch_file>
```

---

## 5.3 Node Configuration: Parameters and Remappings

### Passing Parameters

Parameters allow runtime configuration without code changes:

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='robot_control',
            executable='velocity_controller',
            name='left_arm_controller',
            parameters=[{
                'max_velocity': 2.0,
                'control_frequency': 100.0,
                'joint_names': ['shoulder', 'elbow', 'wrist'],
                'use_sim_time': False
            }],
            output='screen'
        )
    ])
```

**Parameter types**:
- `int`, `float`, `str`, `bool`
- Lists: `[1, 2, 3]` or `['a', 'b', 'c']`
- Nested dictionaries: `{'gains': {'p': 1.0, 'i': 0.1, 'd': 0.05}}`

### Loading Parameters from YAML Files

For complex configurations, use YAML files:

**File**: `config/arm_controller.yaml`
```yaml
left_arm_controller:
  ros__parameters:
    max_velocity: 2.0
    control_frequency: 100.0
    joint_names:
      - shoulder
      - elbow
      - wrist
    pid_gains:
      shoulder:
        p: 10.0
        i: 0.5
        d: 1.0
      elbow:
        p: 8.0
        i: 0.3
        d: 0.8
```

**Launch file**:
```python
import os
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    config = os.path.join(
        get_package_share_directory('robot_control'),
        'config',
        'arm_controller.yaml'
    )
    
    return LaunchDescription([
        Node(
            package='robot_control',
            executable='velocity_controller',
            name='left_arm_controller',
            parameters=[config],
            output='screen'
        )
    ])
```

### Topic, Service, and Action Remapping

Remapping changes the names of topics/services/actions at runtime:

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='robot_control',
            executable='arm_controller',
            name='left_arm_controller',
            remappings=[
                ('/cmd_vel', '/left_arm/cmd_vel'),
                ('/joint_states', '/left_arm/joint_states'),
                ('/goal_pose', '/left_arm/goal_pose')
            ],
            output='screen'
        )
    ])
```

**Use cases**:
- Namespace organization: `/left_arm/cmd_vel`, `/right_arm/cmd_vel`
- Connecting incompatible nodes: remap `/output` to `/input`
- Running multiple instances: remap to unique topic names

---

## 5.4 Launch Arguments for Flexibility

### Declaring Launch Arguments

Arguments make launch files reusable across scenarios:

```python
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node

def generate_launch_description():
    # Declare arguments
    use_sim_arg = DeclareLaunchArgument(
        'use_sim',
        default_value='false',
        description='Use simulation time if true'
    )
    
    robot_name_arg = DeclareLaunchArgument(
        'robot_name',
        default_value='humanoid_v1',
        description='Name of the robot'
    )
    
    # Use arguments in nodes
    return LaunchDescription([
        use_sim_arg,
        robot_name_arg,
        
        Node(
            package='robot_control',
            executable='controller',
            name='controller_node',
            parameters=[{
                'use_sim_time': LaunchConfiguration('use_sim'),
                'robot_name': LaunchConfiguration('robot_name')
            }],
            output='screen'
        )
    ])
```

### Passing Arguments at Runtime

```bash
# Use default values
ros2 launch my_robot_bringup robot.launch.py

# Override arguments
ros2 launch my_robot_bringup robot.launch.py use_sim:=true robot_name:=humanoid_v2
```

### Conditional Launching

Launch nodes conditionally based on arguments:

```python
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.conditions import IfCondition, UnlessCondition
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node

def generate_launch_description():
    use_sim_arg = DeclareLaunchArgument(
        'use_sim',
        default_value='false',
        description='Use simulation'
    )
    
    return LaunchDescription([
        use_sim_arg,
        
        # Launch Gazebo only if use_sim is true
        Node(
            package='gazebo_ros',
            executable='gzserver',
            name='gazebo_server',
            condition=IfCondition(LaunchConfiguration('use_sim')),
            output='screen'
        ),
        
        # Launch hardware interface only if use_sim is false
        Node(
            package='robot_hardware',
            executable='hardware_interface',
            name='hardware_node',
            condition=UnlessCondition(LaunchConfiguration('use_sim')),
            output='screen'
        )
    ])
```

---

## 5.5 ROS 2 Package Structure

### Standard Directory Layout

A well-structured ROS 2 Python package:

```
my_robot_control/
â”œâ”€â”€ package.xml          # Package metadata and dependencies
â”œâ”€â”€ setup.py             # Python package configuration
â”œâ”€â”€ setup.cfg            # Additional metadata
â”œâ”€â”€ resource/            # Package marker (auto-generated)
â”‚   â””â”€â”€ my_robot_control
â”œâ”€â”€ my_robot_control/    # Python source code
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ velocity_controller.py
â”‚   â”œâ”€â”€ position_controller.py
â”‚   â””â”€â”€ utils.py
â”œâ”€â”€ launch/              # Launch files
â”‚   â”œâ”€â”€ robot.launch.py
â”‚   â””â”€â”€ controllers.launch.py
â”œâ”€â”€ config/              # Configuration files (YAML, params)
â”‚   â”œâ”€â”€ controllers.yaml
â”‚   â””â”€â”€ sensors.yaml
â”œâ”€â”€ urdf/                # Robot descriptions
â”‚   â”œâ”€â”€ humanoid.urdf.xacro
â”‚   â””â”€â”€ sensors.urdf.xacro
â”œâ”€â”€ test/                # Unit tests
â”‚   â”œâ”€â”€ test_velocity_controller.py
â”‚   â””â”€â”€ test_position_controller.py
â””â”€â”€ README.md            # Package documentation
```

### Creating a Package

Use `ros2 pkg create`:

```bash
ros2 pkg create --build-type ament_python my_robot_control \
  --dependencies rclpy std_msgs geometry_msgs sensor_msgs

cd my_robot_control
mkdir launch config urdf test
```

**Flags**:
- `--build-type ament_python`: Python package (use `ament_cmake` for C++)
- `--dependencies`: Automatically add dependencies to `package.xml`

---

## 5.6 package.xml Configuration

`package.xml` defines package metadata and dependencies:

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>my_robot_control</name>
  <version>1.0.0</version>
  <description>Control nodes for humanoid robot</description>
  <maintainer email="yourname@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <!-- Build tool dependency -->
  <buildtool_depend>ament_python</buildtool_depend>

  <!-- Runtime dependencies (needed when running nodes) -->
  <depend>rclpy</depend>
  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>
  <depend>tf2_ros</depend>

  <!-- Test dependencies -->
  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

**Dependency Types**:
- `<buildtool_depend>`: Build system tools (e.g., `ament_python`, `ament_cmake`)
- `<depend>`: Both build **and** runtime dependency (most common)
- `<build_depend>`: Only needed at build time
- `<exec_depend>`: Only needed at runtime
- `<test_depend>`: Only for running tests

**Common Fields**:
- `<name>`: Package name (must match directory name)
- `<version>`: Semantic version (MAJOR.MINOR.PATCH)
- `<description>`: One-line package description
- `<maintainer>`: Package maintainer(s)
- `<license>`: Software license (Apache-2.0, MIT, BSD, etc.)

---

## 5.7 setup.py and setup.cfg

### setup.py Configuration

`setup.py` configures Python package installation:

```python
from setuptools import setup
import os
from glob import glob

package_name = 'my_robot_control'

setup(
    name=package_name,
    version='1.0.0',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        # Install launch files
        (os.path.join('share', package_name, 'launch'),
            glob('launch/*.launch.py')),
        # Install config files
        (os.path.join('share', package_name, 'config'),
            glob('config/*.yaml')),
        # Install URDF files
        (os.path.join('share', package_name, 'urdf'),
            glob('urdf/*.urdf') + glob('urdf/*.xacro')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Your Name',
    maintainer_email='yourname@example.com',
    description='Control nodes for humanoid robot',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'velocity_controller = my_robot_control.velocity_controller:main',
            'position_controller = my_robot_control.position_controller:main',
        ],
    },
)
```

**Key sections**:
- `packages`: List of Python packages to install (usually just `[package_name]`)
- `data_files`: Non-Python files (launch, config, URDF)
- `entry_points`: Executable scripts (maps names to Python functions)

**Entry Point Format**:
```python
'executable_name = package_name.module_name:function_name'
```

Example: `'velocity_controller = my_robot_control.velocity_controller:main'`
- Creates executable `velocity_controller`
- Calls `main()` from `my_robot_control/velocity_controller.py`

### setup.cfg

Minimal configuration for modern Python packages:

```cfg
[develop]
script_dir=$base/lib/my_robot_control

[install]
install_scripts=$base/lib/my_robot_control
```

This ensures executables install to the correct directory for ROS 2.

---

## 5.8 Building with colcon

### The colcon Build System

`colcon` is ROS 2's build tool, supporting multiple build types (Python, CMake, others) in a unified workflow.

### Building a Package

```bash
# Navigate to workspace root
cd ~/ros2_ws

# Build all packages
colcon build

# Build specific package
colcon build --packages-select my_robot_control

# Build with symlinks (for faster Python development)
colcon build --symlink-install

# Build with parallel jobs
colcon build --parallel-workers 4
```

**Common Flags**:
- `--packages-select PKG`: Build only `PKG` (and dependencies)
- `--packages-up-to PKG`: Build `PKG` and all its dependencies
- `--symlink-install`: Create symlinks instead of copying files (Python only)
- `--parallel-workers N`: Use `N` parallel build jobs
- `--event-handlers console_direct+`: Show real-time build output

### Build Output

After building, your workspace has:
```
ros2_ws/
â”œâ”€â”€ src/              # Source code
â”œâ”€â”€ build/            # Build artifacts (temporary)
â”œâ”€â”€ install/          # Installed packages
â””â”€â”€ log/              # Build logs
```

---

## 5.9 Workspace Setup and Sourcing

### Workspace Anatomy

ROS 2 uses **overlay** workspaces:
- **Underlay**: Base ROS 2 installation (`/opt/ros/humble`)
- **Overlay**: Your custom workspace (`~/ros2_ws`)

Overlays have higher precedence, allowing you to override base packages.

### Sourcing

**Source the base ROS 2 installation** (do this in `~/.bashrc`):
```bash
source /opt/ros/humble/setup.bash
```

**Source your workspace** after building:
```bash
cd ~/ros2_ws
source install/setup.bash
```

**Add to `~/.bashrc` for persistence**:
```bash
echo "source ~/ros2_ws/install/setup.bash" >> ~/.bashrc
```

### Environment Variables

Key ROS 2 environment variables:

| Variable | Purpose | Example |
|----------|---------|---------|
| `ROS_DOMAIN_ID` | Isolate multiple robots on same network | `export ROS_DOMAIN_ID=42` |
| `ROS_LOCALHOST_ONLY` | Restrict to localhost | `export ROS_LOCALHOST_ONLY=1` |
| `ROS_DISTRO` | ROS 2 distribution | `humble` |

**Set ROS_DOMAIN_ID** to avoid conflicts:
```bash
export ROS_DOMAIN_ID=10  # Use 0-101 for different robot groups
```

---

## 5.10 Dependency Management with rosdep

### What is rosdep?

`rosdep` resolves and installs system dependencies for ROS packages.

### Installing Dependencies

**Initialize rosdep** (once per system):
```bash
sudo rosdep init
rosdep update
```

**Install all dependencies for your workspace**:
```bash
cd ~/ros2_ws
rosdep install --from-paths src --ignore-src -r -y
```

**Flags**:
- `--from-paths src`: Scan `src` directory
- `--ignore-src`: Don't reinstall packages already in workspace
- `-r`: Continue on errors
- `-y`: Auto-confirm installations

### Declaring Dependencies

In `package.xml`, use package names from the [rosdep database](https://github.com/ros/rosdistro):

```xml
<depend>rclpy</depend>                  <!-- ROS package -->
<depend>python3-numpy</depend>          <!-- System package -->
<depend>geometry_msgs</depend>          <!-- ROS message package -->
```

---

## 5.11 Testing Your Package

### Unit Tests with pytest

Create tests in the `test/` directory:

**File**: `test/test_velocity_controller.py`
```python
import pytest
from my_robot_control.velocity_controller import VelocityController

def test_controller_initialization():
    controller = VelocityController()
    assert controller is not None
    assert controller.max_velocity == 2.0

def test_velocity_limits():
    controller = VelocityController()
    clamped = controller.clamp_velocity(5.0)
    assert clamped <= controller.max_velocity
```

### Running Tests

```bash
# From workspace root
colcon test --packages-select my_robot_control

# View test results
colcon test-result --verbose
```

### Linting and Code Quality

Add to `package.xml`:
```xml
<test_depend>ament_copyright</test_depend>
<test_depend>ament_flake8</test_depend>
<test_depend>ament_pep257</test_depend>
```

Run linters:
```bash
ament_flake8 src/my_robot_control/
ament_pep257 src/my_robot_control/
```

---

## 5.12 Complete Package Example

Let's build a complete package with nodes, launch files, config, and tests.

### Package Structure

```
humanoid_arm_control/
â”œâ”€â”€ package.xml
â”œâ”€â”€ setup.py
â”œâ”€â”€ setup.cfg
â”œâ”€â”€ resource/
â”‚   â””â”€â”€ humanoid_arm_control
â”œâ”€â”€ humanoid_arm_control/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ arm_controller.py
â”‚   â””â”€â”€ kinematics.py
â”œâ”€â”€ launch/
â”‚   â””â”€â”€ arm_control.launch.py
â”œâ”€â”€ config/
â”‚   â””â”€â”€ arm_params.yaml
â”œâ”€â”€ test/
â”‚   â””â”€â”€ test_arm_controller.py
â””â”€â”€ README.md
```

### Node: arm_controller.py

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import JointState

class ArmController(Node):
    def __init__(self):
        super().__init__('arm_controller')
        
        # Declare parameters
        self.declare_parameter('control_frequency', 50.0)
        self.declare_parameter('max_velocity', 2.0)
        self.declare_parameter('joint_names', ['shoulder', 'elbow', 'wrist'])
        
        # Get parameters
        self.control_freq = self.get_parameter('control_frequency').value
        self.max_vel = self.get_parameter('max_velocity').value
        self.joint_names = self.get_parameter('joint_names').value
        
        # Publishers and subscribers
        self.cmd_sub = self.create_subscription(
            Twist, 'cmd_vel', self.cmd_callback, 10)
        self.joint_pub = self.create_publisher(JointState, 'joint_states', 10)
        
        # Timer for control loop
        self.timer = self.create_timer(1.0 / self.control_freq, self.control_loop)
        
        self.get_logger().info(f'Arm controller started at {self.control_freq} Hz')
    
    def cmd_callback(self, msg):
        # TODO: Process velocity command
        pass
    
    def control_loop(self):
        # TODO: Publish joint states
        joint_state = JointState()
        joint_state.header.stamp = self.get_clock().now().to_msg()
        joint_state.name = self.joint_names
        # ... set positions, velocities, efforts
        self.joint_pub.publish(joint_state)

def main(args=None):
    rclpy.init(args=args)
    controller = ArmController()
    rclpy.spin(controller)
    controller.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Configuration: config/arm_params.yaml

```yaml
arm_controller:
  ros__parameters:
    control_frequency: 100.0
    max_velocity: 3.0
    joint_names:
      - left_shoulder
      - left_elbow
      - left_wrist
```

### Launch File: launch/arm_control.launch.py

```python
import os
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node

def generate_launch_description():
    # Get package directory
    pkg_dir = get_package_share_directory('humanoid_arm_control')
    
    # Declare arguments
    use_sim_arg = DeclareLaunchArgument(
        'use_sim',
        default_value='false',
        description='Use simulation time'
    )
    
    config_file_arg = DeclareLaunchArgument(
        'config_file',
        default_value=os.path.join(pkg_dir, 'config', 'arm_params.yaml'),
        description='Path to config file'
    )
    
    # Nodes
    arm_controller_node = Node(
        package='humanoid_arm_control',
        executable='arm_controller',
        name='left_arm_controller',
        parameters=[
            LaunchConfiguration('config_file'),
            {'use_sim_time': LaunchConfiguration('use_sim')}
        ],
        output='screen'
    )
    
    return LaunchDescription([
        use_sim_arg,
        config_file_arg,
        arm_controller_node
    ])
```

### setup.py

```python
from setuptools import setup
import os
from glob import glob

package_name = 'humanoid_arm_control'

setup(
    name=package_name,
    version='1.0.0',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        (os.path.join('share', package_name, 'launch'), glob('launch/*.launch.py')),
        (os.path.join('share', package_name, 'config'), glob('config/*.yaml')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Your Name',
    maintainer_email='yourname@example.com',
    description='Arm controller for humanoid robot',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'arm_controller = humanoid_arm_control.arm_controller:main',
        ],
    },
)
```

### package.xml

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>humanoid_arm_control</name>
  <version>1.0.0</version>
  <description>Arm controller for humanoid robot</description>
  <maintainer email="yourname@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_python</buildtool_depend>

  <depend>rclpy</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>

  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

### Build and Run

```bash
# Build
cd ~/ros2_ws
colcon build --packages-select humanoid_arm_control --symlink-install

# Source
source install/setup.bash

# Run
ros2 launch humanoid_arm_control arm_control.launch.py

# Run with arguments
ros2 launch humanoid_arm_control arm_control.launch.py use_sim:=true
```

---

## 5.13 Best Practices

### Documentation

**README.md** should include:
- Package description and purpose
- Installation instructions
- Usage examples (how to run nodes/launch files)
- Configuration options
- Dependencies
- Known issues and TODOs

**Example README.md**:
```markdown
# Humanoid Arm Control

Control package for humanoid robot arm with 3-DOF (shoulder, elbow, wrist).

## Installation

```bash
cd ~/ros2_ws/src
git clone https://github.com/username/humanoid_arm_control.git
cd ~/ros2_ws
rosdep install --from-paths src --ignore-src -r -y
colcon build --packages-select humanoid_arm_control
```

## Usage

Launch arm controller:
```bash
ros2 launch humanoid_arm_control arm_control.launch.py
```

With simulation:
```bash
ros2 launch humanoid_arm_control arm_control.launch.py use_sim:=true
```

## Configuration

Edit `config/arm_params.yaml` to adjust:
- `control_frequency`: Control loop rate (Hz)
- `max_velocity`: Maximum joint velocity (rad/s)
- `joint_names`: List of controlled joints

## Dependencies

- ROS 2 Humble
- `rclpy`, `geometry_msgs`, `sensor_msgs`
```

### Versioning

Follow **Semantic Versioning** (SemVer):
- **MAJOR**: Incompatible API changes
- **MINOR**: Add functionality (backwards-compatible)
- **PATCH**: Bug fixes (backwards-compatible)

Examples:
- `1.0.0`: Initial release
- `1.1.0`: Added new controller type
- `1.1.1`: Fixed velocity clamping bug
- `2.0.0`: Changed parameter names (breaking change)

### Code Organization

- **Modularity**: One node class per file
- **Reusability**: Extract common code to utility modules
- **Configuration**: Use parameters, avoid hardcoding
- **Testing**: Unit test critical algorithms
- **Linting**: Follow PEP 8 style guide

### Package Naming

- Use lowercase with underscores: `my_robot_control`
- Be descriptive: `humanoid_manipulation` vs. `manipulator`
- Avoid ROS 1 naming: Don't use `_ros` suffix (redundant in ROS 2)

---

## Chapter Summary

In this chapter, you learned:

âœ… **Launch files**: Automate multi-node system startup with Python launch syntax  
âœ… **Node configuration**: Pass parameters via dictionaries or YAML files  
âœ… **Remapping**: Change topic/service/action names at runtime  
âœ… **Launch arguments**: Create flexible, reusable launch files  
âœ… **Package structure**: Standard directory layout for ROS 2 packages  
âœ… **package.xml**: Declare dependencies and metadata  
âœ… **setup.py**: Configure entry points and data files  
âœ… **colcon build**: Build packages with parallel compilation  
âœ… **Workspace management**: Understand overlays and sourcing  
âœ… **rosdep**: Resolve and install system dependencies  
âœ… **Testing**: Write unit tests with pytest  
âœ… **Best practices**: Documentation, versioning, code organization

### Key Takeaways

1. **Launch files are essential** for managing complex robotic systems
2. **Python launch syntax** provides full programming capabilities
3. **Parameters and arguments** enable flexible configuration without code changes
4. **Standard package structure** improves collaboration and maintainability
5. **colcon and rosdep** streamline build and dependency management
6. **Documentation and testing** are critical for professional development

### Next Steps

- **Module 2 (Gazebo Simulation)**: Use launch files to start simulation worlds and spawn robots
- **Module 3 (AI-Robot Brain)**: Organize complex perception and planning systems into packages
- **Capstone project**: Structure your humanoid robot system with proper packages and launch files

### Additional Resources

- [ROS 2 Launch Documentation](https://docs.ros.org/en/humble/Tutorials/Intermediate/Launch/Launch-Main.html)
- [colcon Documentation](https://colcon.readthedocs.io/)
- [ament_python Build Type](https://docs.ros.org/en/humble/How-To-Guides/Ament-CMake-Python-Documentation.html)
- [rosdep Database](https://github.com/ros/rosdistro)
- [ROS 2 Package Template](https://github.com/ros2/ros2_tracing)

---

## Module 1 Completion

ðŸŽ‰ **Congratulations!** You've completed Module 1: The Robotic Nervous System (ROS 2).

You now have a solid foundation in:
- ROS 2 architecture and core concepts
- Building nodes with Python (`rclpy`)
- Integrating AI agents with ROS controllers
- Modeling robots with URDF and xacro
- Managing systems with launch files and packages

**You're ready for:**
- **Module 2**: Gazebo simulation and digital twins
- **Module 3**: NVIDIA Isaac and perception pipelines
- **Module 4**: Vision-Language-Action models
- Building your own humanoid robot applications!

---

**Continue to Module 2: Digital Twin (Gazebo Simulation) â†’**
